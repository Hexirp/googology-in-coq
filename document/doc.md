# document

構成的にするために Gallina の項を重視します。そのため、たとえタクティックを使う場合でも、項がコントロールできるように注意してください。

今のところ許容されているタクティックは次になります。

* `refine` タクティック
* `=>` タクティカル
* `exact` タクティック（ただし、一つの項を引数として与えた時のみ）

ゴールが複数に増えたときはビュレットを使います。ビュレットは字下げせず、単独の行に置いてください。その後に続くコマンドは字下げしますが、一番後ろのゴールだけは字下げしなくともよいです。例として、次のようにします。

```
-
  exact x.
-
refine _.
+
  exact y.
+
  exact z.
```

`refine` でゴールが解消される時は、代わりに `exact` を使ってください。

関数や定理などの名前はポーランド記法を基本にしますが、良い名前があるときはそれを使って構いません。次にコードから読み取れる細かい慣習を示します。

* 関数が返すのが `Type` 型の値の時は先頭を大文字にする。
* そうではないときは先頭を小文字にする。
* 依存型に対応している版の関数は `D` を付けて表す。
* ポーランド記法を使う時は、
  * 区切り文字は `_` を使う。
  * `A -> B` は `fun_A_B` と書く。
  * `fun x => t` は `lam_x_t` と書く。
  * `A -> B -> ... Y -> Z` という形の時は `Z` と略せる。
  * `Path x y` という形の時は `x` と略せる。
  * `Path` は `p` と略せる。
  * `idpath` は `1` と略せる。
  * `conc p q` は `cpq` と略せる。
  * `inv p` は `vp` と略せる。
  * `trpt p u` は `T` と略せる。
  * `ap f p` は `A` と略せる。
  * `p x` は `p` が点ごとの道であれば `P` と略せる。
  * ポーランド記法が入れ子になった時は `path_'conc_p_1'_p_q` という風にする。
  * 区別が付かないときは `L` と `R` を付けたりする。

行が長すぎるときは、ちょうどよい区切りで改行してしてください。読みやすくするために字下げも行ってください。

宇宙のレベルについては必ず記述してください。レベルの制約は Coq がチェックしてくれるので、たとえ制約が空だとしても記述してください。

## GiC.Core

次のゴールがあるとします。

```
______________________________________(1/1)
Path@{i} x z
```

これを次のように分割したいとします。

```
______________________________________(1/2)
Path@{i} x y
______________________________________(2/2)
Path@{i} y z
```

そんな時は、次のように書きます。

```
refine (conc _ (_ : Path@{i} y _)).
```

## GiC.Path

作者でも全ての定理を覚えられる自信がないので、 `SearchPattern` を使うことを推奨します。
