# document

構成的にするために Gallina の項を重視します。そのため、たとえタクティックを使う場合でも、項がコントロールできるように注意してください。

今のところ許容されているタクティックは次になります。

* `refine` タクティック
* `=>` タクティカル
* `exact` タクティック（ただし、一つの項を引数として与えた時のみ）

ゴールが複数に増えたときはビュレットを使います。ビュレットは字下げせず、単独の行に置いてください。その後に続くコマンドは字下げしますが、一番後ろのゴールだけは字下げしなくともよいです。例として、次のようにします。

```
-
  exact x.
-
refine _.
+
  exact y.
+
  exact z.
```

関数や定理などの名前はポーランド記法を基本にしますが、良い名前があるときはそれを使って構いません。次に、判断基準の一例を示します。

* 関数が返すのが `Type` 型の値の時は先頭を大文字にする。
* そうではないときは先頭を小文字にする。
* `A -> B` は `fun_A_B` と書く。
* `fun x => t` は `lam_x_t` と書く。
* `A -> B -> ... Y -> Z` という形の時は `Z` と略せる。
* `Path x y` という形の時は `x` と略せる。
* `Path` は `p` と略せる。
* `idpath` は `1` と略せる。
* `conc p q` は `cpq` と略せる。
* `inv p` は `vp` と略せる。
* `trpt p u` は `T` と略せる。
* `ap f p` は `A` と略せる。
* `p x` は `p` が点ごとの道であれば `P` と略せる。
* ポーランド記法が入れ子になった時は `path_'conc_p_1'_p_q` という風にする。

行が長すぎるときは、ちょうどよい区切りで改行してしてください。読みやすくするために字下げも行ってください。

宇宙のレベルについては必ず記述してください。 Coq がチェックしてくれるので制約も記述してください。

## GiC.Core

次のゴールがあるとします。

```
______________________________________(1/1)
Path@{i} x z
```

これを次のように分割したいとします。

```
______________________________________(1/2)
Path@{i} x y
______________________________________(2/2)
Path@{i} y z
```

そんな時は、次のように書きます。

```
refine (conc _ (_ : Path@{i} y _)).
```
