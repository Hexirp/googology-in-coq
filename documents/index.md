# document

googology-in-coq は、プログラムとして証明を書くことを目標としています。そのため、 Gallina としての項をソースコードから簡単に読み取れるような記述を維持しなければなりません。

## コーディング

本プロジェクトのスタイルと合わないため、標準ライブラリは使用しません。

`Set` と `Prop` は使いません。これは homotopy type theory の上に立って開発を行う際に障害になるためです。

帰納原理 (induction principle) の機能は、項をコントロールすることを困難にする上に、 `Set` と `Prop` を使うため、使用しません。次のような指定を Vernacular ファイルの最初で行ってください。

```
Unset Elimination Schemes .
```

universe polymorphism については必ず使用します。次のような指定を Vernacular ファイルの最初で行ってください。

```
Set Universe Polymorphism .

Set Polymorphic Inductive Cumulativity .
```

証明戦術は項のコントロールを困難にすることもありますが、有用であるため、限定的に使用します。詳細は証明戦術の節を見てください。使用するときは、次のような指定を Vernacular ファイルの最初で行ってください。

```
Set Default Proof Mode "Classic" .

Set Default Goal Selector "!" .
```

カスタム表記 (notation) や暗黙引数 (implicit argument) や暗黙変換 (coercion) や型クラス (typeclass) などの機能は、項をコントロールすることを困難にするため、なるべく使いません。

定義における universe level については必ず明示的に記述してください。定義における universe level の制約は、たとえ制約が空だとしても制約がないということをチェックしてくれますので、記述してください。 Gallina の式における宇宙のレベルは、常に記述してください。

universe level については、基本的に linear なものとして扱ってください。また、基本的には一つの level のみを使ってください。

モジュールファイルの分け方の基準は、モジュールとしてどのようなものを提供するかという点に重きを置きます。

`Require Import` は使いません。モジュールファイルに対する操作である `Require` とモジュールに対する操作である `Import` では対象が異なるため、それを明確にしたいからです。

### コメント

定義の前には、それを簡単に説明するドキュメントとしてのコメントを付けても構いません。定義を上手く分けられる時は coqdoc の見出し機能を使ってください。そうした場合、その直後に節の意味を説明するコメントをつけましょう。

```coq
(** ... *)

Definition foo a b c .

(** ... *)

Definition bar a b c .
```

ドキュメントとしてのコメントは、上記のように記述してください。 coqdoc が根差す文芸的プログラミングの考え方に従って、ソースコードとドキュメントが対等になるように記述します。

coqdoc には見出し機能があり、たとえば `(** * ... *)` は `h1` 要素に変換されますが、これは使わないでください。 `h1` 要素が coqdoc によりページの冒頭に追加されるので、 `h1` 要素が重複してしまうことになります。

独自に訳語を充てる場合は、それを説明するコメントを書くようにします。

### 名前

連番を使用します。 `A_2024_02_06_0012` のように、 `A` の後に日付を繋げて、その後に四桁の連番を繋げます。

頻繁に使用する定義である場合、日本語を使用した別名を付与します。

### フォーマット

大抵のトークンの間で空白を空けます。特に、 `( x )` のようにします。例外は、 `Foo@{ i }` と `?[a]` と `[a]: {` です。

coqdoc の仕様により、改行するとスペースが挿入されてしまうため、ドキュメントとしてのコメントでは改行を行いません。

改行と字下げについての慣習を次に示します。

内側の式を改行する時は、外側の式も改行します。

`( x )` は、次のようにします。

```coq
(
    x
)
```

`f x y z` は、次のようにします。

```coq
f
    x
    y
    z
```

`let _ : _ := _ in _` は、次のようにします。

```coq
let
    _ : _ := _
in
    _
```

`forall _ : _ , _` は、次のようにします。

```coq
forall _ : _ ,
_
```

`forall _ : _ , _` は、次のようにします。

```coq
forall
    _ : _
,
_
```

`_ -> _` は、次のようにします。

```coq
_
->
_
```

`match _ as _ in _ retrun _ with _ => _ | _ => _ | _ => _ end` は、次のようにします。

```coq
match
    _
as
    _
in
    _
return
    _
with
    _ => _ | _ => _ | _ => _
end
```

`match _ as _ in _ retrun _ with _ => _ | _ => _ | _ => _ end` は、次のようにします。

```coq
match
    _
as
    _
in
    _
return
    _
with
    _ => _
    |
    _ => _
    |
    _ => _
end
```

`Definition a _ _ _ : _ := _ .` は、次のようにします。

```coq
Definition a _ _ _ : _
    := _
.
```

`Definition a _ _ _ : _ := _ .` は、次のようにします。

```coq
Definition a _ _ _
    : _
    := _
.
```

`Definition a _ _ _ : _ := _ .` は、次のようにします。

```coq
Definition a
    _
    _
    _
    : _
    := _
.
```

`Inductive A _ _ _ : _ := _ : _ | _ : _ | _ : _ .` は次のようにします。

```coq
Inductive A _ _ _ : _
    := _ : _ | _ : _ | _ : _
.
```

`Inductive A _ _ _ : _ := _ : _ | _ : _ | _ : _ .` は次のようにします。

```coq
Inductive A _ _ _
    : _
    := _ : _ | _ : _ | _ : _
.
```

`Inductive A _ _ _ : _ := _ : _ | _ : _ | _ : _ .` は次のようにします。

```coq
Inductive A
    _
    _
    _
    : _
    :=
        _ : _
        |
        _ : _
        |
        _ : _
.
```

`fix a _ _ _ { struct _ } : _ := _` は次のようにします。

```coq
fix a _ _ _ { struct _ } : _
    := _
```

`fix a _ _ _ { struct _ } : _ := _` は次のようにします。

```coq
fix a _ _ _ { struct _ }
    : _
    := _
```

`fix a _ _ _ { struct _ } : _ := _` は次のようにします。

```coq
fix a
    _
    _
    _
    { struct _ }
    : _
    := _
```

### 証明戦術

証明戦術は、 Gallina の項をコントロールすることを困難にします。しかし、証明を段階的に行える利便性も大きいため、限定的に使用します。

主に、 Gallina としての項が長くなり過ぎた時に、それを分割するために使用します。

Gallina の項をコントロールできるとして許容されている証明戦術は次になります。

* `refine` 証明戦術
* `exact` 証明戦術（ただし、 Coq に組み込みの "ltac\_plugin" で定義される証明戦術のこと）

目標が複数に増えたときは波括弧を使います。

```
refine _ .
{
    exact x .
}
{
    refine _ .
    {
        exact y .
    }
    {
        exact z .
    }
}
```

`refine` で目標が解消される時は、代わりに `exact` を使ってください。

## ビルド

ビルドは shell ファイルを使って行います。

Coq では Makefile を使うのがスタンダードのようなのですが、 Makefile を自動生成するためのファイルがあったり、そのためのツールがあったりと、複数の層があって訳が分からない上に、 Windows で使うことが困難なため、 Windows 環境では shell ファイルを使っています。

CI では Makefile を生成させるファイルを使っています。

### \_\_CoqProject

CI で使用するファイルです。

### compile.sh

`files.sh` に記述されたファイルを対象にして、コンパイルを行います。標準ライブラリを使用しないために `-nois` を、詳細なログを出力させるために `-verbose` を、モジュールの構成のために `-R theories/ Googology_In_Coq` を、それぞれ `coqc` のオプションに与えています。

生成する物は次の通りです。

* `theories/[x0]/[x1]/.../[xn].v` から生成される物
  * `theories/[x0]/[x1]/.../.[xn].aux`
  * `theories/[x0]/[x1]/.../[xn].glob`
  * `theories/[x0]/[x1]/.../[xn].vo`
  * `theories/[x0]/[x1]/.../[xn].vok`
  * `theories/[x0]/[x1]/.../[xn].vos`

### coqc.sh

`coqc` のラッパーです。これを参照することで、別の環境でも、このファイルを書き換えるだけで対応できるようになっています。

### coqdoc.sh

`coqdoc` のラッパーです。これを参照することで、別の環境でも、このファイルを書き換えるだけで対応できるようになっています。

### coqide.sh

`coqide` のラッパーです。これを参照することで、別の環境でも、このファイルを書き換えるだけで対応できるようになっています。

### edit.sh

プロジェクトの編集を開始します。標準ライブラリを使用しないために `-nois` を、モジュールの構成のために `-R theories/ Googology_In_Coq` を、それぞれ `coqide` のオプションに与えています。

これを使うと、標準ライブラリとの名前の衝突が発生せず、 `Require Googology_In_Coq.Base.` というような記述が正常に動作します。

### files.sh

コンパイルやドキュメントの生成などの対象となるファイルを記述します。 `foo.v baa.v ` という風にファイルと空白が交互に出力されます。

### coq\_Path.sh

`coqc.sh` と `coqide.sh` と `coqtop.sh` で使用する Coq のバイナリファイルがあるファイルパスを供給します。

### googology-in-coq.opam

CI で使います。

### make\_document.sh

`files.sh` に記述されたファイルを対象にして、プロジェクトのコメントによるドキュメントを生成します。日本語でも正常に動作させるために `-utf8` を、生成先として `docs/` を指定するために `-d docs/` を、モジュールの構成のために `-R theories/ Googology_In_Coq` を、それぞれ `coqdoc` のオプションに与えています。

生成する物は次の通りです。

* `coqdoc.css`
* `index.html`
* `theories/[x0]/[x1]/.../[xn].v` から生成される物
  * `docs/[x0].[x1].....[xn].html`

## プログラミング

タクティックを使う時は、次のように進めます。

```coq
Proof.
  exact _. (* 穴を埋めることが出来ないというエラーが出る。 *)
Defined.

Proof.
  refine ( foo _ ). (* 証明を進める。 *)
  exact _. (* 穴を埋めることが出来ないというエラーが出る。 *)
Defined.

Proof.
  refine ( foo _ ).
  refine ( baa _ ). (* 証明を進める。 *)
  exact baz. (* 証明を終わらせる。 *)
Defined
```

## 開発

コミットメッセージのタイトルには「何を」変更したかを書いてください。本文には「どうして」変更したかを書いてください。

コミットメッセージが 50 文字を超えてしまうことを恐れないでください。単語の数の方が重要な基準です。

ブランチは木構造として上下関係を設定します。 master ブランチが上で working ブランチは下という風に考えます。

下のブランチを上のブランチにマージしようとすると、コンフリクトが起こる可能性があります。この時は、上のブランチを下のブランチにマージしてコンフリクトを解消してください。

もし A というブランチを再構成したい場合は、新しいブランチを切ります。このブランチの名前は自由ですが、説明のために A' という仮の名前を付けます。そして、 A' に A の変更を cherry-pick などで取り込みます。ここで A' に取り込むべき細かい変更が残っている場合は master ブランチへ cherry-pick します。そして、 A' ブランチを master ブランチにマージした後に、取り込まない変更を切り捨てるために A ブランチを ours 戦略でマージします。この方法は、二つ以上のブランチへ再構成する時も適用可能です。もし、 A と A' を完全に一致させられるのなら octopus 戦略も使えます。

merge request は、マージする時にワンクッションを置きたい場合に作成してください。それをマージする前に、変更を取り込ませるブランチを変更が取り込まれるブランチにマージしてください。

merge する時は no fast forward としてください。ただし、 git pull の時は例外です。

rebase は、なるべく使わないでください。ただし、 git pull で変更が少ない時は例外です。

`beta` から `alpha` への merge request を自動的にマージ出来るときは、次の場合です。

* fast-forward である。
* approved である。
* CI が通っている。
