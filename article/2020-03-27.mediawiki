Coq で巨大数論 (Googology in Coq) は、単純に巨大数論を Coq で形式化しようという試みを行う、日刊連載のブログ記事です。

== 2020-03-27 ==

初回はユニット型を作成します。ユニット型は値が一つだけしかない型です。カリー＝ハワード対応を通して恒真式 ( \( \top \) ) に対応します。

<pre class="code">
Inductive Unit@{i} : Type@{i} := unit : Unit.
</pre>

<code>Inductive</code> キーワードを用いてユニット型を定義します。この型の構築子は一つだけであり、それは何も引数を受け取りません。

== 2020-03-28 ==

今日は関数型の表記を追加します。関数型はもともと Coq に組み込まれている全称型もしくは依存積型 <code>forall x, T</code> の特殊な場合として表されます。具体的に言うならば、ここでの <code>T</code> が <code>x</code> に依存していない場合が関数型です。

<pre class="code">
Notation "x -> y" := (forall (_ : x), y) (at level 99, right associativity, y at level 200).
</pre>

わざわざ <code>forall</code> を書くのは面倒なので矢印で書けるように記法を設定します。変数を <code>_</code> で使用されないと宣言することで、変数に依存しないことを強制しています。後に続く記述は記法としての優先順位や結合性を設定しています。

== 2020-03-29 ==

今日は空の型を作成します。空の型は値を持たない型です。カリー＝ハワード対応を通して矛盾 ( \( \bot \) ) に対応します。

<pre class="code">
Inductive Void@{i} : Type@{i} :=.
</pre>

空の型は構築子を持たない型として表されます。

== 2020-03-30 ==

今日は直積型を作成します。直積型の値は、二つの型の値のそれぞれを持ち、それらから成り立ちます。カリー＝ハワード対応を通して論理積 ( \( A \land B \) ) に対応します。

<pre class="code">
Inductive Prod@{i j} (A : Type@{i}) (B : Type@{j}) : Type@{max(i,j)} :=
  | pair : A -> B -> Prod A B.

Arguments pair {A} {B} a b.
</pre>

まず、直積型の型は、二つの型を受け取り一つの型を返すものです。宇宙のレベルについては、受け取るレベルに制約がかからないように <code>max(_,_)</code> を使っています。直積型の構築子は、二つの型の値それぞれを受け取ります。この構築子は、本来は四つの引数を持つのですが、そのうち型を受け取る二つの引数については推論できることが多いので、それらを推論するように <code>Arguments</code> を使って設定しています。

== 2020-03-31 ==

今日は直積型の第一引数の射影関数を作成します。

<pre class="code">
Definition fst@{i j} {A : Type@{i}} {B : Type@{j}} (x : Prod@{i j} A B) : A :=
  match x with pair a b => a end.
</pre>

これからも直積を基本とする型には射影関数を定義していきたいと思います。ちなみに、直積を基本とする型は余帰納型として射影関数により定義するのが理想です。圏論の双対になっているから美しくなります（帰納型／余帰納型、直和／直積、構築子／射影関数）。理想に反して <code>Prod</code> を <code>Inductive</code> で定義する理由は、 Coq においての余帰納型は射影関数を基本として定義できなかったりバグが見つかることがあったり自動で簡約されなかったりと色々扱いが悪いからです。

== 2020-04-01 ==

今日は直積型の第二引数の射影関数を作成します。

<pre class="code">
Definition snd@{i j} {A : Type@{i}} {B : Type@{j}} (x : Prod@{i j} A B) : B :=
  match x with pair a b => b end.
</pre>

宇宙のレベルは \( T : T \) という型付けが成り立つ状況を回避するためのものです。これは Girard's paradox という型理論における Russell's paradox をもたらすため許容されません。こうして宇宙のレベルを導入した結果、宇宙のレベルをどう扱うかという問題が出てきました。定義においてレベルを一つに固定すると、それぞれのレベルで別々に定義する必要が出てきてしまいます。これは非現実的なので、宇宙多相というレベルに関する量化が必要になります。宇宙多相を実現するにあたってレベルを引数として扱う必要があります。その際に Coq ではレベルを値と別種のものとして扱います。レベルに関する量化は、必ず定義の一番外側に置かれます。一方で Agda では別の方法を取っているようです。レベルに関して量化された型 <code>(n : Level) → Set n</code> は <code>Setω</code> という型が付きます。そのままだと <code>Setω : Setω</code> が成り立ちパラドックスが復活するように見えますが、 <code>Setω</code> を使うことが出来る箇所には制限があるため（少なくとも分かりやすい）矛盾は起きません。

== 2020-04-02 ==

今日は直和型を作成します。直和型の値は、二つの型の値のいずれかを持ち、それらから成り立ちます。カリー＝ハワード対応を通して論理和 ( \( A \lor B \) ) に対応します。

<pre class="code">
Inductive Sum@{i j} (A : Type@{i}) (B : Type@{j}) : Type@{max(i,j)} :=
  | left : A -> Sum A B
  | right : B -> Sum A B.

Arguments left {A} {B} a.
Arguments right {A} {B} b.
</pre>

直和型の型は、二つの型を受け取り一つの型を返すものです。直和型の構築子は二つ存在し、それらは二つの型の値のいずれかをそれぞれ受け取ります。これらの構築子は型についての引数を暗黙であると設定ています。

直和型は、二つの異なる値を持ちます。この性質は等号を体系に導入したときに問題を生じます。論理式として \( A \lor B \) を証明したいときは、単純に考えるならば \( A \) を与えるか \( B \) を与えるかです。これを型と値として見做したとき、二種類の異なる値が存在することになります。そのどれを選択するかで後に続く証明に影響をもたらすことになります。命題を使うときは証明の内容に影響されずに使えるはずなのに、それでは困ります。このような状況を解決する手段の一つとして Homotopy Type Theory の truncation というものがあります。この記事では使われることがないと思いますが紹介しておきます。

== 2020-04-03 ==

今日は依存和型を作成します。依存和型の値は、最初の型の値を一つ持ち、さらにそれに対応する二つ目の型の値を持ちます。構築子は型についての引数を暗黙であると設定しています。依存和型は存在型とも呼ばれ、カリー＝ハワード対応を通して存在量化 ( \( \exists x \ldotp P \) ) に対応します。

<pre class="code">
Inductive DSum@{i j} (A : Type@{i}) (B : A -> Type@{j}) : Type@{max(i,j)}
  := dpair : forall a : A, B a -> DSum A B.

Arguments dpair {A} {B} a b.
</pre>

存在型もしくは依存和型には、二つの特徴的な使われ方があります。一つ目は二番目の引数に焦点を当てた使い方です。二番目の引数の型の違いを吸収して一つの型として扱うという使い方です。その際には一つ目の引数は重要ではありません。直和型も二つの型を一つの型に纏めたいときに使われることがあり、この使い方は直和型の正当な進化だと言えるかもしれません。二つ目は一番目の引数に焦点に当てた使い方です。一番目の引数に型で表現した条件を課するという使い方です。二番目の引数は条件から何かの帰結を導きたい時の他は無視されます。このような使われ方があるため、私は一番目の引数を暗黙だと設定しませんでした。なお、もちろん特徴的な使われ方は二種類に限られるわけではありません。
