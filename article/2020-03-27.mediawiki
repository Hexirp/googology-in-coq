Coq で巨大数論 (Googology in Coq) は、単純に巨大数論を Coq で形式化しようという試みを行う、日刊連載のブログ記事です。

== 2020-03-27 ==

初回はユニット型を作成します。ユニット型は値が一つだけしかない型です。カリー＝ハワード対応を通して恒真式 ( \( \top \), <code>\top</code> ) に対応します。

<pre class="code">
Inductive Unit@{i} : Type@{i} := unit : Unit.
</pre>

<code>Inductive</code> キーワードを用いてユニット型を定義します。この型の構築子は一つだけであり、それは何も引数を受け取りません。

== 2020-03-28 ==

今日は関数型の表記を追加します。関数型はもともと Coq に組み込まれている全称型もしくは依存積型 <code>forall x, T</code> の特殊な場合として表されます。具体的に言うならば、ここでの <code>T</code> が <code>x</code> に依存していない場合が関数型です。

<pre class="code">
Notation "x -> y" := (forall (_ : x), y) (at level 99, right associativity, y at level 200).
</pre>

わざわざ <code>forall</code> を書くのは面倒なので矢印で書けるように記法を設定します。変数を <code>_</code> で使用されないと宣言することで、変数に依存しないことを強制しています。後に続く記述は記法としての優先順位や結合性を設定しています。

== 2020-03-29 ==

今日は空の型を作成します。空の型は値を持たない型です。カリー＝ハワード対応を通して矛盾 ( \( \bot \), <code>\bot</code> ) に対応します。

<pre class="code">
Inductive Void@{i} : Type@{i} :=.
</pre>

空の型は構築子を持たない型として表されます。

== 2020-03-30 ==

今日は直積型を作成します。直積型の値は、二つの型の値のそれぞれを持ち、それらから成り立ちます。カリー＝ハワード対応を通して論理積 ( \( A \land B \), <code>\land</code> ) に対応します。

<pre class="code">
Inductive Prod@{i j} (A : Type@{i}) (B : Type@{j}) : Type@{max(i,j)} :=
  | pair : A -> B -> Prod A B.

Arguments pair {A} {B} a b.
</pre>

まず、直積型の型は、二つの型を受け取り一つの型を返すものです。宇宙のレベルについては、受け取るレベルに制約がかからないように <code>max(_,_)</code> を使っています。直積型の構築子は、二つの型の値それぞれを受け取ります。この構築子は、本来は四つの引数を持つのですが、そのうち型を受け取る二つの引数については推論できることが多いので、それらを推論するように <code>Arguments</code> を使って設定しています。

== 2020-03-31 ==

今日は直積型の第一引数の射影関数を作成します。

<pre class="code">
Definition fst@{i j} {A : Type@{i}} {B : Type@{j}} (x : Prod@{i j} A B) : A :=
  match x with pair a b => a end.
<pre class="code">

これからも直積を基本とする型には射影関数を定義していきたいと思います。ちなみに、直積を基本とする型は、余帰納型として射影関数により定義した方が、圏論の双対の上で美しいです。このような型を <code>Inductive</code> を使って定義する理由は、 Coq においての余帰納型は射影関数を基本として定義できなかったりバグが見つかることがあったり自動で簡約されなかったりと、色々扱いが悪いからです。さらに範囲を広げて、型を定義する時は <code>Inductive</code> を使えるなら使います。

== ??? ==

今日は直和型を作成します。直和型の値は、二つの型の値のいずれかを持ち、それから成り立ちます。カリー＝ハワード対応を通して論理和 ( \( A \lor B \), <code>\lor</code> ) に対応します。

<pre class="code">
Inductive Sum@{i j} (A : Type@{i}) (B : Type@{j}) : Type@{max(i,j)} :=
  | left : A -> Sum A B
  | right : B -> Sum A B.

Arguments left {A} {B} a.
Arguments right {A} {B} b.
</pre>

直和型の型は、二つの型を受け取り一つの型を返すものです。直和型の構築子は二つ存在し、それらは二つの型の値のいずれかをそれぞれ受け取ります。これらの構築子は型についての引数を暗黙であると設定ています。

直和型は、二つの異なる値を持ちます。この性質は等号を言語に導入したときに問題を生じます。論理式として \( A \lor B \) を証明したいときは、単純に考えるならば \( A \) を与えるか \( B \) を与えるかです。これを型と値として見做したとき、二種類の異なる値が存在することになります。そのどれを選択するかで後に続く証明に影響をもたらすことになります。命題を使うときは証明の内容に影響されずに使えるはずなのに、それでは困ります。このような状況を解決する手段の一つとして Homotopy Type Theory の truncation というものがあります。このライブラリでは使われることがないと思いますが紹介しておきます。

宇宙のレベルは \( T : T \) という型付けが成り立つ状況を回避するためのものです。これは Girard's paradox という Russell's paradox の型理論におけるバージョンをもたらすため許容されません。くして宇宙のレベルを導入した結果、宇宙のレベルをどう扱うかという問題が出てきました。 Coq ではレベルを型と別種のものとして扱い、通常の引数にレベルに関して量化された値を与えることはできません。一方で Agda では別の方法を取っているようです。

== ??? ==

存在型もしくは依存和型には、二つの特徴的な使われ方があります。一つ目は二つ目の引数に焦点を当てた使い方です。 Haskell の存在型の使われ方に似ています。この場合は二つ目の引数の型の違いを吸収するためであって、一つ目の引数は重要ではありません。二つ目は一つ目の引数に焦点にあてた使い方です。一つ目の引数に条件を加えるために依存和型を使うため、二つ目の引数は条件から何らかの帰結を導きたい時以外では重要ではありません。このような二つの使われ方があるため、私はどちらの引数も暗黙だと設定しませんでした。
