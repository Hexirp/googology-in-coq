Coq で巨大数論 (Googology in Coq) は、単純に巨大数論を Coq で形式化しようという試みを行う、日刊連載のブログ記事です。

== 2020-03-27 ==

初回はユニット型を作成します。ユニット型は値が一つだけしかない型です。カリー＝ハワード対応を通して恒真式 ( \( \top \) ) に対応します。

<pre class="code">
Inductive Unit@{i} : Type@{i} := unit : Unit.
</pre>

<code>Inductive</code> キーワードを用いてユニット型を定義します。この型の構築子は一つだけであり、それは何も引数を受け取りません。

== 2020-03-28 ==

今日は関数型の表記を追加します。関数型はもともと Coq に組み込まれている全称型もしくは依存積型 <code>forall x, T</code> の特殊な場合として表されます。具体的に言うならば、ここでの <code>T</code> が <code>x</code> に依存していない場合が関数型です。

<pre class="code">
Notation "x -> y" := (forall (_ : x), y) (at level 99, right associativity, y at level 200).
</pre>

わざわざ <code>forall</code> を書くのは面倒なので矢印で書けるように記法を設定します。変数を <code>_</code> で使用されないと宣言することで、変数に依存しないことを強制しています。後に続く記述は記法としての優先順位や結合性を設定しています。

== 2020-03-29 ==

今日は空の型を作成します。空の型は値を持たない型です。カリー＝ハワード対応を通して矛盾 ( \( \bot \) ) に対応します。

<pre class="code">
Inductive Void@{i} : Type@{i} :=.
</pre>

空の型は構築子を持たない型として表されます。

== 2020-03-30 ==

今日は直積型を作成します。直積型の値は、二つの型の値のそれぞれを持ち、それらから成り立ちます。カリー＝ハワード対応を通して論理積 ( \( A \land B \) ) に対応します。

<pre class="code">
Inductive Prod@{i j} (A : Type@{i}) (B : Type@{j}) : Type@{max(i,j)} :=
  | pair : A -> B -> Prod A B.

Arguments pair {A} {B} a b.
</pre>

まず、直積型の型は、二つの型を受け取り一つの型を返すものです。宇宙のレベルについては、受け取るレベルに制約がかからないように <code>max(_,_)</code> を使っています。直積型の構築子は、二つの型の値それぞれを受け取ります。この構築子は、本来は四つの引数を持つのですが、そのうち型を受け取る二つの引数については推論できることが多いので、それらを推論するように <code>Arguments</code> を使って設定しています。

== 2020-03-31 ==

今日は直積型の第一引数の射影関数を作成します。

<pre class="code">
Definition fst@{i j} {A : Type@{i}} {B : Type@{j}} (x : Prod@{i j} A B) : A :=
  match x with pair a b => a end.
</pre>

これからも直積を基本とする型には射影関数を定義していきたいと思います。ちなみに、直積を基本とする型は余帰納型として射影関数により定義するのが理想です。圏論の双対になっているから美しくなります（帰納型／余帰納型、直和／直積、構築子／射影関数）。理想に反して <code>Prod</code> を <code>Inductive</code> で定義する理由は、 Coq においての余帰納型は射影関数を基本として定義できなかったりバグが見つかることがあったり自動で簡約されなかったりと色々扱いが悪いからです。

== 2020-04-01 ==

今日は直積型の第二引数の射影関数を作成します。

<pre class="code">
Definition snd@{i j} {A : Type@{i}} {B : Type@{j}} (x : Prod@{i j} A B) : B :=
  match x with pair a b => b end.
</pre>

宇宙のレベルは \( T : T \) という型付けが成り立つ状況を回避するためのものです。これは Girard's paradox という型理論における Russell's paradox をもたらすため許容されません。こうして宇宙のレベルを導入した結果、宇宙のレベルをどう扱うかという問題が出てきました。定義においてレベルを一つに固定すると、それぞれのレベルで別々に定義する必要が出てきてしまいます。これは非現実的なので、宇宙多相というレベルに関する量化が必要になります。宇宙多相を実現するにあたってレベルを引数として扱う必要があります。その際に Coq ではレベルを値と別種のものとして扱います。レベルに関する量化は、必ず定義の一番外側に置かれます。一方で Agda では別の方法を取っているようです。レベルに関して量化された型 <code>(n : Level) → Set n</code> は <code>Setω</code> という型が付きます。そのままだと <code>Setω : Setω</code> が成り立ちパラドックスが復活するように見えますが、 <code>Setω</code> を使うことが出来る箇所には制限があるため（少なくとも分かりやすい）矛盾は起きません。

== 2020-04-02 ==

今日は直和型を作成します。直和型の値は、二つの型の値のいずれかを持ち、それらから成り立ちます。カリー＝ハワード対応を通して論理和 ( \( A \lor B \) ) に対応します。

<pre class="code">
Inductive Sum@{i j} (A : Type@{i}) (B : Type@{j}) : Type@{max(i,j)} :=
  | left : A -> Sum A B
  | right : B -> Sum A B.

Arguments left {A} {B} a.
Arguments right {A} {B} b.
</pre>

直和型の型は、二つの型を受け取り一つの型を返すものです。直和型の構築子は二つ存在し、それらは二つの型の値のいずれかをそれぞれ受け取ります。これらの構築子は型についての引数を暗黙であると設定ています。

直和型は、二つの異なる値を持ちます。この性質は等号を体系に導入したときに問題を生じます。論理式として \( A \lor B \) を証明したいときは、単純に考えるならば \( A \) を与えるか \( B \) を与えるかです。これを型と値として見做したとき、二種類の異なる値が存在することになります。そのどれを選択するかで後に続く証明に影響をもたらすことになります。命題を使うときは証明の内容に影響されずに使えるはずなのに、それでは困ります。このような状況を解決する手段の一つとして Homotopy Type Theory の truncation というものがあります。この記事では使われることがないと思いますが紹介しておきます。

== 2020-04-03 ==

今日は依存和型を作成します。依存和型の値は、最初の型の値を一つ持ち、さらにそれに対応する二つ目の型の値を持ちます。構築子は型についての引数を暗黙であると設定しています。依存和型は存在型とも呼ばれ、カリー＝ハワード対応を通して存在量化 ( \( \exists x \ldotp P \) ) に対応します。

<pre class="code">
Inductive DSum@{i j} (A : Type@{i}) (B : A -> Type@{j}) : Type@{max(i,j)}
  := dpair : forall a : A, B a -> DSum A B.

Arguments dpair {A} {B} a b.
</pre>

存在型もしくは依存和型には、二つの特徴的な使われ方があります。一つ目は二番目の引数に焦点を当てた使い方です。二番目の引数の型の違いを吸収して一つの型として扱うという使い方です。その際には一つ目の引数は重要ではありません。直和型も二つの型を一つの型に纏めたいときに使われることがあり、この使い方は直和型の正当な進化だと言えるかもしれません。二つ目は一番目の引数に焦点に当てた使い方です。一番目の引数に型で表現した条件を課するという使い方です。二番目の引数は条件から何かの帰結を導きたい時の他は無視されます。このような使われ方があるため、私は一番目の引数を暗黙だと設定しませんでした。なお、もちろん特徴的な使われ方は二種類に限られるわけではありません。

== 2020-04-04 ==

今日は依存和型の第一引数を取り出す関数を作成します。

<pre class="code">
Definition dfst@{i j} {A : Type@{i}} {B : A -> Type@{j}} (x : DSum@{i j} A B) : A
  := match x with dpair a b => a end.
</pre>

望月新一教授により出版された ABC 予想を証明したとする論文が PRIMS に掲載されると京都大学が 4 月 3 日に発表しました。掲載されるまでの査読は約 8 年を要しました。<ref>{{cite_web |url=https://mainichi.jp/articles/20200403/k00/00m/040/093000c |title=未解明だった数学の超難問「ABC予想」を証明　京大の望月教授　斬新・難解で査読に8年 |date=2020-04-03 |website=毎日新聞 |publisher=毎日新聞 |accessdate=2020-04-04 }}</ref><ref>{{cite_web |url=https://www.yomiuri.co.jp/science/20200403-OYT1T50201/ |title=数学の未解決難問「ＡＢＣ予想」、望月・京大教授が証明…論文掲載へ |date=2020-04-03 |website=読売新聞オンライン |publisher=読売新聞 |accessdate=2020-04-04 }}</ref><ref>{{cite_web |url=https://www3.nhk.or.jp/news/html/20200403/k10012366491000.html |title=難問「ＡＢＣ予想」京大教授が証明 専門家「歴史に残る成果」 |date=2020-04-03 |website=NHKニュース |publisher=日本放送協会 |accessdate=2020-04-04 }}</ref><ref>{{cite_web |url=https://www.itmedia.co.jp/news/articles/2004/03/news155.html |title=査読8年、京大教授の「ABC予想」証明理論　ついに論文誌掲載へ |date=2020-04-03 |website=ITmedia NEWS |publisher=ITmedia |accessdate=2020-04-04 }}

このタイムリーなニュースについて二つの話題を紹介しましょう。

ABC 予想を証明したとする論文の査読には 8 年を要しました。インターネットの上でも査読に掛かった時間を話題にする人を私は見ました。数学は当然のことながら時間が経つにつれて複雑化してきます。しかし、それが度を超すと人生の全てをかけても一つの分野の最先端に到達すらできない人が増えていくことになります。それは、数学にとっての危機であるように思えます。人間が検証を出来ないのならば機械に検証させればいいという考え方があります。カリー＝ハワード対応を通した方法が Coq や Agda で実現されており、それは四色定理の証明において実行されています。しかし、旧来のシステムで検証する際には詳細な表現に注意を向けなければならず、作業が困難です。たとえば、ゼロと後続による自然数とバイナリによる自然数との二つの表現があったとしましょう。ゼロと後続による自然数で或る性質を定義したとき、それをバイナリによる自然数に適用することは出来ません。また、集合の商のような同一視を行うことも機械的な検証が難しく、数学の基盤を機械で検証する妨げになっていました。

そのような問題を解決して数学の基盤を機械に移そうとするプロジェクトが Univalent Foundations です。最初に Univalent Axiom (単葉公理とでも訳すればいいのでしょうか）が複数の表現を同一視することを可能にします。次に Higher Inductive Type (高階帰納型) が値の同一視を実現します。その基礎は Homotopy Type Theory (HoTT) という型理論です。 Coq による実装ではいくつかの公理を要していましたが、つい最近に Cubical Type Theory という公理がなく univalent axiom が定理である型システムが Agda に実装されました。

== ??? ==

<code>natOrd_m_S_n</code> は https://github.com/Hexirp/googology-in-coq/compare/ad6954416c4ae19eaa181020ac348ebc590970e3...ace068b9a473aaec07fcf2891fb545976109c81b の一連のコミットで証明を行っている。 Coq ではどうやって命題を証明するかの参考になると思う。
